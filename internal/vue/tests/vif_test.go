package vue_tests

import (
	"testing"

	"github.com/microsoft/typescript-go/shim/fourslash"
	"github.com/microsoft/typescript-go/shim/lsp/lsproto"
	"github.com/microsoft/typescript-go/shim/testutil"
)

func TestVIfEmptyDirective(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div [|v-if=""|]></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_005)},
			Message: "v-if is missing expression.",
		},
	})
}

func TestVElseIfMissingExpression(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div v-if="true"></div>
	<div [|v-else-if=""|]></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_005)},
			Message: "v-else-if is missing expression.",
		},
	})
}

func TestVElseIfWithoutAdjacent(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div [|v-else-if|]="true"></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_003)},
			Message: "v-else-if has no adjacent v-if or v-else-if.",
		},
	})
}

func TestVElseWithoutAdjacent(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div [|v-else|]></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_003)},
			Message: "v-else has no adjacent v-if or v-else-if.",
		},
	})
}

func TestVElseIfAfterNonConditionalElement(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div v-if="true"></div>
	<span>not part of chain</span>
	<div [|v-else-if|]="true"></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_003)},
			Message: "v-else-if has no adjacent v-if or v-else-if.",
		},
	})
}

func TestVIfDuplicateConditionalDirective1(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div v-if="true"></div>
	<div v-else-if="true" [|v-if|]="false"></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_004)},
			Message: "Multiple conditional directives cannot coexist on the same element.",
		},
	})
}

func TestVIfMultipleConditionalDirective2(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div v-if="true" [|v-else-if|]="true"></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_004)},
			Message: "Multiple conditional directives cannot coexist on the same element.",
		},
	})
}

func TestVIfMultipleConditionalDirective3(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<template>
	<div v-if="true"></div>
	<div v-else-if="true" [|v-else|]></div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{
		{
			Code:    &lsproto.IntegerOrString{Integer: ptrTo[int32](1_000_004)},
			Message: "Multiple conditional directives cannot coexist on the same element.",
		},
	})
}

func TestVIfNarrowingAcrossChain(t *testing.T) {
	t.Parallel()

	defer testutil.RecoverAndFail(t, "Panic on fourslash test")
	content := withVueNodeModules(t, `// @filename: file.vue
<script setup lang="ts">
	type Foo = { kind: 'foo'; foo: number }
	type Bar = { kind: 'bar'; bar: boolean }
	const value = {} as unknown as Foo | Bar
</script>

<template>
	<div v-if="value.kind === 'foo'">
		{{ value/*1*/.foo/*2*/ }}
	</div>
	<div v-else-if="value.kind === 'bar'">
		{{ value/*3*/.bar/*4*/ }}
	</div>
	<div v-else>
		{{ value/*5*/ }}
	</div>
</template>`)
	f, done := fourslash.NewFourslash(t, nil, content)
	defer done()

	f.VerifyQuickInfoAt(t, "1", "(property) value: Foo", "")
	f.VerifyQuickInfoAt(t, "2", "(property) foo: number", "")
	f.VerifyQuickInfoAt(t, "3", "(property) value: Bar", "")
	f.VerifyQuickInfoAt(t, "4", "(property) bar: boolean", "")
	f.VerifyQuickInfoAt(t, "5", "(property) value: never", "")

	f.VerifyNonSuggestionDiagnostics(t, []*lsproto.Diagnostic{})
}
